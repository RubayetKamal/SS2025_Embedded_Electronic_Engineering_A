\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[backend=bibtex]{biblatex}
\addbibresource{references.bib}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Partition-based scheduling on multi-core systems\\
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Rubayet Kamal}
\IEEEauthorblockA{\textit{Electronic Engineering} \\
\textit{Hochschule Hamm-Lippstadt}\\
Lippstadt, Germany\\
rubayet.kamal@stud.hshl.de}
}

\maketitle

\begin{abstract}
Systems with components of varying criticality often require stronger verification for high-criticality parts compared to low-criticality ones. In multi-core systems, partitioning reduces the complexity of scheduling by assigning partitions to different cores, allowing isolated execution with optional inter-partition communication. However, partitioned scheduling faces resource utilization challenges similar to the bin-packing problem: tasks may fail to be assigned to any processor even when sufficient total capacity exists. This inefficiency is particularly severe when tasks have high individual utilization, potentially limiting system resource usage to as little as half. Moreover, assigning tasks while maintaining load balance and predictability is an NP-hard problem. This paper explores the fundamentals of partition-based scheduling and examines heuristic allocation and scheduling algorithms. Inspired by \cite{AbdallahGB24}, a clustering-based task allocation strategy is implemented in C to simulate and visualize the distribution of tasks across homogeneous cores.


% The study focuses on the clustering-based task allocation strategy implemented in \cite{b1}, which uses the Earliest Deadline First (EDF) scheduling algorithm to ensure that the utilization factor remains less than 1 and communication cost between cores is minimized. A simulation written in C based on the strategy implemented in \cite{b1} is done to visualise the distribution of tasks among different homoegenous cores. 
% Furthermore, work done in \cite{b2} has extended partitioned EDF scheduling by incorporating Quality of Service (QoS) constraints, allowing tasks to occasionally skip instances in order to handle overload and energy constraints more flexibly. This QoS-aware approach enhances the robustness of partitioned scheduling by improving schedulability in multicore systems while minimizing energy consumption.
\end{abstract}

\begin{IEEEkeywords}
component, formatting, style, styling, insert
\end{IEEEkeywords}

\section{Introduction}
Real-time systems are often classified based on their timing requirements into soft, firm, and hard real-time systems \cite{6122386}.  Real-time computer system must react to stimuli from its environment within time intervals dictated by its environment. The instant when a result must be produced is called a deadline. If a result has utility even after the deadline has passed, the deadline is classified as soft, otherwise it is firm. If severe consequences could result if a firm deadline is missed, the deadline is called hard \cite{kopetzDist}. Firm real-time systems are often referred to as mixed-criticality systems due to the presence of some tasks being highly critical than others \cite{zamora2013}.

The development of mixed-criticality real-time systems presents several challenges, particularly in task scheduling and resource allocation. While power management techniques such as Dynamic Voltage and Frequency Scaling (DVFS) and Dynamic Power Management (DPM) have been explored for energy optimization, these methods were initially designed for uniprocessor systems \cite{6122386}. With the increasing computational demands and advances in integrated circuit miniaturization, multi-core platforms is a valid solution for providing the necessary computational resources.

Scheduling tasks on multi-core systems introduces two key problems \cite{AbdallahGB24}:
\begin{itemize}
    \item \textbf{Allocation problem (spatial organization)} : assigning each task to a core.
    \item \textbf{Scheduling problem (temporal organization)} : determining the execution order of tasks on each core.
\end{itemize}

According to~\cite{7832222}, task scheduling heavily depends on efficient task allocation. A clustering-based scheduling algorithm addresses this by partitioning tasks that frequently communicate onto the same or nearby cores, minimizing communication overhead \cite{AbdallahGB24}. As per~\cite{zamora2013}, partitioning isolates different parts of the system to prevent mutual interference. However, partitioned scheduling faces resource utilization issues similar to the bin-packing problem: a task might not fit on any core despite sufficient total system capacity. This inefficiency becomes significant when individual task utilizations are high, and in the worst case, only half of the systemâ€™s resources may be utilized.

To address this, semi-partitioned scheduling (a hybrid approach) has been proposed. In this method, most tasks are statically assigned to fixed cores, while a small number of tasks are split into subtasks across different cores, enabling limited task migration \cite{AbdallahGB24}. Each core must still pass schedulability tests after assignment. Clustering concepts are used to group communicating tasks together, and in \cite{AbdallahGB24}, the author employed textit{Earliest Deadline First (EDF)} algorithm for local scheduling of each core.

Although semi-partitioned scheduling shows theoretical performance improvements, its practical adoption remains limited due to concerns about context switch overhead and migration costs. As discussed in~\cite{5953668}, experiments suggest that for task sets with reasonable parameters, semi-partitioned scheduling can indeed outperform traditional partitioned approaches even under realistic overhead conditions.

While low-power scheduling on heterogeneous cores is a known NP-complete problem~\cite{7832222}, this paper focuses on homogeneous cores, where task allocation remains NP-hard. Inspired by~\cite{AbdallahGB24}, we implement a clustering-based task allocation strategy that aims to minimize communication costs, balance load across cores, and improve system feasibility for mixed-criticality real-time systems.

The remainder of this paper is structured as follows: 
Section~\ref{sec:fundamentals} presents the core concepts required for understanding real-time mixed critical systems along with multi-core architectures and multi-core scheduling strategies.
Section~\ref{sec: partition-based scheduling} defines partition-based scheduling mechanisms, highlighting the differences between static and dynamic partitioning, and discussing the objectives and challenges associated with partitioning. The importance of task partitioning in mixed-criticality systems is also discussed. 
Section~\ref{sec: clustering-based scheduling} outlines the clustering-based scheduling strategy and task allocation methodology, as originally proposed in~\cite{AbdallahGB24}. 
Section~\ref{sec:implementation} describes the implementation of the algorithm using C code snippets, developed to simulate the strategy. It also presents the simulation results and discusses the key findings. 
Finally, Section~\ref{sec: conclusion} concludes the paper and summarizes the main contributions.




\section{Background Material}
\label{sec:fundamentals}
Before exploring the strategy implemented in this paper, it is necessary to discuss the fundamental concepts to ensure that the terms used in later sections are familiar. This section is divided into three subsections: \ref{subsec:task and task types} introduces real-time systems and tasks; \ref{subsec: architecture of multi-core processors} covers multi-core processor architectures; and \ref{subsec: scheduling approach on multicore architecture} explains scheduling approaches on multi-core systems. The objective of this section is to clarify all necessary terminology before implementing and simulating the desired partition-based scheduling algorithm.

\subsection{Tasks and Task Types in Real-Time Systems}
\label{subsec:task and task types}
A real-time system evolves as a function of physical time~\cite{kopetzDist}. A set of related jobs that execute to support a system function is called a task~\cite{9999}. Therefore, a real-time task is primarily defined by its temporal properties.

According to~\cite{5465974}, a periodic task $\tau_i$ is characterized by two parameters:
\begin{itemize}
    \item \textbf{Worst-Case Execution Time (WCET) $W_i$}: The maximum amount of time a task $\tau_i$ could take to execute.
    \item \textbf{Period $T_i$}: The fixed time interval between successive arrivals of the task.
\end{itemize}
These properties are assumed to be constant for all task instances in a homogeneous multi-core architecture.

Additional temporal characteristics of real-time tasks, as listed in~\cite{AbdallahGB24}, include:
\begin{itemize}
    \item \textbf{Release Time or Arrival Time ($R_i$)}: The time at which a task $\tau_i$ becomes eligible to start execution.
    \item \textbf{Deadline ($D_i$)}: The latest time by which the task must complete its execution.
    \item \textbf{Latency ($L_i$)}: The remaining time before a task either starts execution or its deadline occurs.
    \item \textbf{Laxity or Slack Time ($X_i$)}: The maximum time a task can be delayed after activation and still meet its deadline.
\end{itemize}

Figure~\ref{fig:temporal_properties_of_task} illustrates the temporal properties of a real-time task.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\linewidth]{Temporal properties of task.png}
    \caption{Temporal properties of a task}
    \label{fig:temporal_properties_of_task}
\end{figure}

Real-time tasks can be classified as either \textit{periodic} or \textit{aperiodic}:
\begin{itemize}
    \item \textbf{Periodic Tasks}: These tasks consist of an infinite sequence of identical activities, called instances or jobs, that are activated regularly at a constant rate~\cite{butazo99}. Periodic tasks are characterized by strict deadlines and form the majority of tasks in a real-time application. According to~\cite{french18}, a periodic task $\tau_i$ is typically modeled by four parameters: $(R_i, W_i, D_i, P_i)$~\cite{AbdallahGB24}.
    
    \item \textbf{Aperiodic Tasks}: These tasks also consist of a sequence of identical jobs, but their activations are unpredictable and not evenly spaced. Aperiodic tasks are generally modeled by a single parameter, $W_i$, representing their worst-case execution time~\cite{AbdallahGB24}.
\end{itemize}

A special class of aperiodic tasks is \textit{sporadic tasks}~\cite{butazo99}. Sporadic tasks, while aperiodic in execution time, have their execution rate constrained by a minimum inter-arrival time. They are modeled by the parameters $(W_i, D_i, T_{\text{min}})$, where $T_{\text{min}}$ is the minimum time interval between two consecutive activations, and $D_i$ is the critical delay~\cite{AbdallahGB24}.




\subsection{Architecure of multi-core processors}
\label{subsec: architecture of multi-core processors}

\subsection{Scheduling approach on multicore architecture}
\label{subsec: scheduling approach on multicore architecture}

\section{Partition-based Scheduling}
\label{sec: partition-based scheduling}

% \subsection{Scheduling in multi-core platforms}
% \label{subsec: scheduling in multicore platforms}

% In \cite{b17}, the authors propose tasks allocation heuristics based on the list by assigning each of them a priority. This list (there is only one list for all the tasks: global approach) determines the order of tasks allocation on different cores of processors. At each step of the heuristic, a task is selected from the list of candidate tasks to be scheduled on core, then the list is updated, this is repeated until the list is empty. This single scheduling strategy is applied to all cores. In other words if dependent tasks are placed on different cores then, the communication cost and the energy consumption are so high. So, the system performance decreases and we obtain a poor quality of service. The goal of this paper is to reduce this communication cost using an optimal allocation of task strategy.  In \cite{b1} which is based on works of \cite{b7}, an heuristic approach to frequently place each Cluster (contains communicating tasks) on the same core or on the nearest core to reduce the cost of communication and adding the verification constraints on core loads. The idea is that the code with the least load will be chosen. 




% There are two basic approaches for scheduling real-time tasks on multi-core platforms:
% \begin{itemize}
%     \item Global Approach: Each task can execute on any available processor at run time. The objective is to allocate at each instant tasks to cores P. For this, there is a single queue for all tasks and single scheduling strategy is used which applies the set of cores (see Figure 2). In this case, an essen- tial property is that tasks migration is allowed.

%     \item Partitioned Approach: Each task is assigned to a processor beforehand and during run time it can only execute on this particular processor. The objective is to definitively assign each task to one core or to define subset of tasks each assigned to core.It is thus possible to apply single-core strategies on each of the architectureâ€™s processors, in which each processor has their own execution queue (see Figure 3).
%     \item Hybrid approach: The hybrid or semi-partitioned approach is derived from the partitioned approach. In this approach, certain occurrences of tasks can be executed on different cores (migration). Each core receives certain tasks after the partitioning heuristic and can perform an exchange of tasks with other cores, this is called task migration. It should be noted that for all these approaches, there is a necessary condition of schedulability, (see equation (3)). 
% \end{itemize}

% Recent studies showed that the partitioned approach is superior in scheduling hard real-time systems, for both theoretical and practical reasons. However, partitioned scheduling still suffers from resource waste similar to the bin-packing problem: a task would fail to be partitioned to any of the processors when the total available capacity of the whole system is still large. When the individual task utilization is high, this waste could be significant, and in the worst-case only half of the system resource can be used. 

% \subsection{Scheduling}
% \label{subsec: scheduling}
% Partitioning a task set is equivalent to the Bin-Packing problem: how to place n objects of different sizes in m identical boxes. This problem is known to be NP-hard. Heuristic-based scheduling algoritms are the most common approaches for task scheduling. These are usually classified into three classes:

% \begin{itemize}
%     \item Priority-based scheduling: priorities are calculated and assigned to the tasks which are then scheduled on the processors according to their priorities.
%     \item Duplication-based scheduling: while tasks are allocated to a processor, its parent (and predecessor) tasks are duplicated to occupy the idle times of the processor to eliminate the communication delay that occurs when message is passed from the parent tasks to the allotted task.
%     \item In cluster-based scheduling, some tasks, that need to communicate among themselves, are grouped together to form a cluster. Clusters are then scheduled on to an available processor. The main problem arises when the number of clusters is greater than the number of processors. This leads to programming the communicating clusters on the same processor and which remains in the nearest processor.
% \end{itemize}

% \section{Partition-based scheduling mechanism}
% \label{sec: partition-based scheduling mechanism}

% Static algorithms are those in which scheduling decisions are based on fixed
% parameters, assigned to tasks before their activation.

% Dynamic algorithms are those in which scheduling decisions are based on
% dynamic parameters that may change during system evolution.

% An algorithm is said to be heuristic if it is guided by a heuristic function
% in taking its scheduling decisions. A heuristic algorithm tends toward the
% optimal schedule, but does not guarantee finding it


\section{Clustering-based scheduling strategy}
\label{sec: clustering-based scheduling}

\section{Implementation in C}
\label{sec:implementation}

\section{Simulation and Outcome}
\label{sec: simulation and outcome}



\section{Conclusion}
\label{sec: conclusion}


\section*{Acknowledgment}


% \begin{thebibliography}{00}
% \bibitem{b1} H. Ben Abdallah, H. Gharsellaoui, and S. Bouamama, "A Novel Partitioning Approach for Real-Time
% Scheduling of Mixed-Criticality Systems," in Proceedings of the 16th International Conference on
% Agents and Artificial Intelligence, Rome, Italy, 2024, pp. 882â€“889.
% \bibitem{b2} N. Abdallah, A. Queudet, M. Chetto and R. H. Chehade, "Partitioned EDF scheduling in multicore systems with quality of service constraints," 2011 18th IEEE International Conference on Electronics, Circuits, and Systems, Beirut, Lebanon, 2011, pp. 764-767, doi: 10.1109/ICECS.2011.6122386. keywords: {Real time systems;Quality of service;Sorting;Processor scheduling;Partitioning algorithms;Optimal scheduling;Energy consumption}.
% \bibitem{b3} J. Zamorano, J. Puente, "On real-time partitioned multicore systems," Universidad PoliteÂ´cnica de Madrid (UPM), Spain, 2013 
% \bibitem{b4} N. Guan, M. Stigge, W. Yi and G. Yu, "Fixed-Priority Multiprocessor Scheduling with Liu and Layland's Utilization Bound," 2010 16th IEEE Real-Time and Embedded Technology and Applications Symposium, Stockholm, Sweden, 2010, pp. 165-174, doi: 10.1109/RTAS.2010.39. keywords: {Processor scheduling;Scheduling algorithm;Real time systems;Multiprocessing systems;Application software;Information technology;Computer science;Partitioning algorithms;Testing;H infinity control;real-time systems;utilization bound;multiprocessor;fixed priority scheduling}
% \bibitem{b5} Y. Zhang, N. Guan, Y. Xiao and W. Yi, "Implementation and empirical comparison of partitioning-based multi-core scheduling," 2011 6th IEEE International Symposium on Industrial and Embedded Systems, Vasteras, Sweden, 2011, pp. 248-255, doi: 10.1109/SIES.2011.5953668. keywords: {Real time systems;Scheduling;Processor scheduling;Sleep;Linux;Context;Data structures} 
% \bibitem{b56} 2013 IEEE 21st International Symposium on Modelling, Analysis and Simulation of Computer and
% Telecommunication Systems: IEEE, 2013.
% \bibitem{b7} P. Bhardwaj and V. Kumar, "An Effective Load Balancing Task Allocation Algorithm using Task
% Clustering," IJCA, vol. 77, no. 7, pp. 32â€“39, 2013, doi: 10.5120/13410-1064.
% \bibitem{b8} G. C. Buttazzo, Hard Real-Time Computing Systems. Boston, MA: Springer US, 2011.
% A. Crespo, M. Masmano, J. Coronel, S. PeirÃ³, P. Balbastre, and J. SimÃ³, "Multicore partitioned
% systems based on hypervisor," IFAC Proceedings Volumes, vol. 47, no. 3, pp. 12293â€“12298, 2014,
% doi: 10.3182/20140824-6-ZA-1003.02410.
% \bibitem{b9}Z. Dong, J. Wang, G. F. Riley, and S. Yalamanchili, "A Study of the Effect of Partitioning on Parallel
% Simulation of Multicore Systems," in 2013 IEEE 21st International Symposium on Modelling, Analysis
% and Simulation of Computer and Telecommunication Systems, San Francisco, CA, USA, 2013, pp.
% \bibitem{b10} 2021 IEEE 27th Real-Time and Embedded Technology and Applications Symposium (RTAS): IEEE,
% 2021.
% \bibitem{b11}H. Kopetz, Real-Time Systems. Boston, MA: Springer US, 2011.

% \bibitem{b12}Proceedings of the 16th International Conference on Agents and Artificial Intelligence: SCITEPRESS -
% Science and Technology Publications, 2024.
% [15] N. Saranya and R. C. Hansdah, "Dynamic Partitioning Based Scheduling of Real-Time Tasks in
% Multicore Processors," in 2015 IEEE 18th International Symposium on Real-Time Distributed
% Computing, Auckland, New Zealand, 2015, pp. 190â€“197.
% \bibitem{b13}V. Sarkar, "Partitioning and scheduling parallel programs for multiprocessors,"
% \bibitem{b14}"Scheduling Algorithms for Multiprogramming in a Hard- Real-Time Environment,"
% \bibitem{b15}J. Wang, T. Zhang, D. Shen, X. S. Hu, and S. Han, "APaS: An Adaptive Partition-Based Scheduling
% Framework for 6TiSCH Networks," in 2021 IEEE 27th Real-Time and Embedded Technology and
% Applications Symposium (RTAS), Nashville, TN, USA, 2021, pp. 320â€“332.
% \bibitem{b16} K. M. K. Abdelsalam, S. M. Khamis, H. M. Bahig, and H. M. Bahig, "A multicore-based algorithm for
% optimal multi-way number partitioning," Int. j. inf. tecnol., vol. 15, no. 6, pp. 2929â€“2940, 2023, doi:
% 10.1007/s41870-023-01328-1.
% \bibitem{b17} K. Zhu and Y. Ding, "Research on Low Power Scheduling of Heterogeneous Multi Core Mission Based on Genetic Algorithm," 2017 9th International Conference on Measuring Technology and Mechatronics Automation (ICMTMA), Changsha, China, 2017, pp. 219-223, doi: 10.1109/ICMTMA.2017.0059. keywords: {Multicore processing;Scheduling;Power demand;Algorithm design and analysis;Partitioning algorithms;Scheduling algorithms;Genetic algorithm;heterogeneous multi-core;key task;low power scheduling;algorithm research},
% \bibitem{b18} Zhang, H. (2012). ordonnancement de tÃ¢ches temps rÃ©el dans les systÃ¨mes multicoeur. PhD thesis, UniversitÃ© de Nantes.
% \bibitem{b19} Huang, J. and Raabe, A. (2011). Energy-aware task allocation for network-on-chip based heterogeneous multiprocessor systems. In Parallel, Distributed and Network-Based Processing (PDP), 2011 19th Euromicro International Conference on, page 447â€“454. IEEE.




% \end{thebibliography}
% \vspace{12pt}
% \color{red}
% IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.
\printbibliography

\end{document}
